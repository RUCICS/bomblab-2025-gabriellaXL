# bomblab 报告

姓名：郭心蕾

学号：2024201512

| 总分 | phase_1 | phase_2 | phase_3 | phase_4 | phase_5 | phase_6 | secret_phase |
| --------- | ------------- | ------------- | ------------- | ----------------- |-----------|-----------|-----------|
| 6        | 1            | 1            | 1            | 1 |1  |1  |0  |


scoreboard 截图：
![image](./imgs/image.png)

<!-- TODO: 用一个scoreboard的截图，本地图片，放到 imgs 文件夹下，不要用这个 github，pandoc 解析可能有问题 -->

## 解题报告

<!-- 对你拆掉的每个phase进行分析，并写出你得出答案的历程 -->

<!-- 如果能用伪代码还原题目源代码最佳（不属于先前提到的大段代码），语言描述自己的分析也可，每道题目的图片不建议超过两张 -->

### phase_1

```c
// 题目答案
The future can't just be made out of sanity.
```

题目思路:
main函数中：
```
    132c:	e8 bb 0c 00 00       	call   1fec <read_line>
    1331:	48 89 c7             	mov    %rax,%rdi # 将read_line返回值（%rax）拷贝给%rdi
    1334:	e8 fc 00 00 00       	call   1435 <phase_1> # 向phase_1传入%rdi(第一个参数储存位置)
```

在phase_1中：
```
    1439:	48 8d 35 40 1d 00 00 	lea    0x1d40(%rip),%rsi        # 3180 <_IO_stdin_used+0x180> # %rip的值是1440 故%rsi此处存的值是0x1d40+0x1440=0x3180
    1440:	e8 41 08 00 00       	call   1c86 <strings_not_equal> 
```
如果strings_not_equal返回值%eax不为0，也就是两个字符串不相等，炸弹就会爆炸。
这里strings_not_equal函数两个参数，第一个%rdi的值由main函数中read_line给出，第二个%rsi由1439行算出。
所以在strings_not_equal这行打断点：(gdb) b *(phase_1+11)，然后查看%rsi中字符串：(gdb) x/s $rsi ，显示：0x555555557180: "The future can't just be made out of sanity."这就是第一题的输入。






### phase_2

```c
// 题目答案
1362152 1775206 525157 597250
```

题目思路：
```
0x000055555555547d <+40>:    lea    0x214d(%rip),%rsi #字符串"%d %d %d %d"地址
   0x0000555555555484 <+47>:    call   0x555555555150 <__isoc99_sscanf@plt> # 调用sscanf
   0x0000555555555489 <+52>:    cmp    $0x4,%eax      # 检查是否成功读取4个整数
   0x000055555555548c <+55>:    jne    0x5555555554a2 <phase_2+77> # 不是4个则跳转到爆炸
```

```
148e: lea    0x4c9b(%rip),%rdi        # 6130 <matA.2> 
# rdi指向matA.2,这是矩阵A
1495: lea    0x10(%rsp),%rbx # rbx指向栈上空间，这是计算结果存储位置
...
14bb: lea    0x4c4e(%rip),%rsi        # 6110 <matB.1>
# rsi指向matB.1 这是矩阵B
```

```
14a9: add    $0x1,%r11d    # i++ 外层循环
14ad: add    $0xc,%rdi     # rdi += 12 (3个int，一行
14b1: add    $0x8,%rbx     # rbx += 8 (2个int，一行
14b5: cmp    $0x2,%r11d    # i != 2  循环2次 说明结果矩阵有2行
...
14d8: mov    (%rdi,%rax,4),%edx   # matA[i][k] 访问4字节整数数组
14db: imul   (%rsi,%rax,8),%edx   # matB[k][j] 步长8字节 2int matB是列优先存储的3×2矩阵
...
14e1: add    $0x1,%rax     # k++ 内层循环
14e5: cmp    $0x3,%rax     # k != 3 循环3次
...
14ee: add    $0x1,%r8d     # j++ 中层循环​
14f2: add    $0x4,%r9      # 结果指针+4
14fa: cmp    $0x2,%r8d     # j != 2 循环2次 结果矩阵有2列
# 2×3矩阵matA × 3×2矩阵matB = 2×2矩阵matC
```
从栈顶开始rsp+0,rsp+4...rsp+12分别是第1个，第2个...第4个输入整数，rsp+16...rsp+28分别是计算结果的第1个值...第4个值，rsp+32是金丝雀值;
用gdb查看两个矩阵值，计算出所求矩阵乘法结果矩阵matC的值作为输入
```
Breakpoint 2, 0x0000555555556126 in phase_defused ()
(gdb) x/6dw 0x55555555a130
0x55555555a130 <matA.2>:        827     899     485     68
0x55555555a140 <matA.2+16>:     445     264
(gdb) x/6dw 0x55555555a110
0x55555555a110 <matB.1>:        493     887     629     678
0x55555555a120 <matB.1+16>:     802     891
```
```
A = [[827, 899, 485],
     [68, 445, 264]]
B = [[493, 887],
     [629, 678],
     [802, 891]]
```

### phase_3

```c
// 题目答案
5 -680
```

题目思路：
```
1559: lea    0x4(%rsp),%rcx # 第2个整数
155e: mov    %rsp,%rdx # 第1个整数
1561: lea    0x206f(%rip),%rsi   # format string
1568: call   __isoc99_sscanf # 读入两个整数
156d: cmp $0x1,%eax # 读到小于等于1个就爆炸
1570: jle explode
1572: cmpl $0x0,0x4(%rsp) # 第二个数需>0
1577: js explode
...
157e: cmpl $0x7,(%rsp) # 第一个数需在0到7之间
1582: ja explode
...
# 发现跳转表结构
1588: mov    (%rsp),%eax        # eax = x
158b: lea    table(%rip),%rdx   # rdx 加载跳转表基址
1592: movslq (%rdx,%rax,4),%rax # rax = table[x] 根据索引 $x$ 从表中取出一个偏移量
1596: add    %rdx,%rax
1599: jmp    *%rax # 根据输入的第一个数字，直接跳到代码的不同位置
...
15ca: cmpl $0x5,(%rsp) # 第一个参数需要小于等于5
15ce: jg <phase_3+0x92>
15d0: cmp %eax,0x4(%rsp) # 第二个参数在%eax
15d4: je 15db <phase_3+0x97>
15d6: 1eeb <explode_bomb>
```
gdb:
```
(gdb) x/s 0x5555555575d7
0x5555555575d7: "%d %d" # 输入格式
Breakpoint 6, 0x00005555555555d0 in phase_3 ()
(gdb) p/d $eax
$1 = -680 # 输入结果的第二个参数
```

### phase_4

```c
// 题目答案
31 AB 
```
题目思路：
```
# 输入格式分析：
lea    0x1acd(%rip),%rsi  # 加载格式字符串地址
call   __isoc99_sscanf@plt
cmp    $0x2,%eax          # 必须读取2个输入
jne    0x55555555578f <phase_4+157>  # 不是2个就爆炸
```

```
# 第一个值：
mov    $0x5,%edi         # 参数一为5
call   0x555555555633 <func4_1>  # 调用func4_1(5)
cmp    %eax,0xc(%rsp)    # 比较返回值与输入的第一个值
jne    explode_bomb      
```

```
# 第二个值：
lea    0x10(%rsp),%rdi   # 第二个输入的地址
call   string_length     # 计算字符串长度
cmp    $0x2,%eax         # 长度必须为2
jne    explode_bomb      
```

```
lea    0x14(%rsp),%rbx   # 缓冲区地址
mov    $0x42,%r8d        # 参数5 = 0x42 = 'B'
mov    $0x43,%ecx        # 参数4 = 0x43 = 'C'
mov    $0x41,%edx        # 参数3 = 0x41 = 'A'
mov    $0x1a,%esi        # 参数2 = 0x1a = 26
mov    $0x5,%edi         # 参数1 = 5
call   0x555555555659 <func4_2>  # func4_2(5, 26, 'A', 'C', 'B')
```

```
# 最后比较：
lea    0x10(%rsp),%rdi   # 原始输入字符串
mov    %rbx,%rsi         # func4_2处理后的字符串
call   strings_not_equal
test   %eax,%eax
jne    explode_bomb
```

```
# 分析func4_1:
(gdb)  disas func4_1
Dump of assembler code for function func4_1:
   0x0000555555555633 <+0>:     mov    $0x0,%eax
   0x0000555555555638 <+5>:     test   %edi,%edi # if (n <= 0) 返回eax=0
   0x000055555555563a <+7>:     jle    0x555555555658 <func4_1+37>
   0x000055555555563c <+9>:     mov    %edi,%eax
   0x000055555555563e <+11>:    cmp    $0x1,%edi # 如果n==1，返回eax=edi=1
   0x0000555555555641 <+14>:    je     0x555555555658 <func4_1+37>
   0x0000555555555643 <+16>:    sub    $0x8,%rsp
   0x0000555555555647 <+20>:    sub    $0x1,%edi # n-=1
   0x000055555555564a <+23>:    call   0x555555555633 <func4_1> # 递归
   0x000055555555564f <+28>:    lea    0x1(%rax,%rax,1),%eax # 2*f(n-1)+1
   0x0000555555555653 <+32>:    add    $0x8,%rsp
   0x0000555555555657 <+36>:    ret
   0x0000555555555658 <+37>:    ret
```
所以：
```
func4_1(0) = 0
func4_1(1) = 1
func4_1(n) = 2 * func4_1(n-1) + 1
计算func4_1(5)(第一个输入值):
func4_1(1) = 1
func4_1(2) = 2 * 1 + 1 = 3
...
func4_1(5) = 2 * 15 + 1 = 31
```

```
# 分析func4_2:
   0x0000555555555659 <+0>:     push   %r15 # 保存被调用者保存寄存器
   0x000055555555565b <+2>:     push   %r14
   0x000055555555565d <+4>:     push   %r13
   0x000055555555565f <+6>:     push   %r12
   0x0000555555555661 <+8>:     push   %rbp
   0x0000555555555662 <+9>:     push   %rbx
   0x0000555555555663 <+10>:    sub    $0x8,%rsp # 对齐栈
   0x0000555555555667 <+14>:    mov    %edx,%r12d # 参数3 c1
   0x000055555555566a <+17>:    mov    %ecx,%r13d # 参数4 c2
   0x000055555555566d <+20>:    mov    %r9,%rbp # 参数6 out
   0x0000555555555670 <+23>:    cmp    $0x1,%edi # 参数1 n 判断n==1 递归base case
   0x0000555555555673 <+26>:    je     0x55555555569f <func4_2+70>
   0x0000555555555675 <+28>:    mov    %esi,%ebx # rsi参数2 ebx=k
   0x0000555555555677 <+30>:    mov    %r8d,%r14d # r14=c3
   0x000055555555567a <+33>:    lea    -0x1(%rdi),%r15d
   0x000055555555567e <+37>:    mov    %r15d,%edi
   0x0000555555555681 <+40>:    call   0x555555555633 <func4_1> #func4_1(n-1) t = 2^(n-1) - 1
   0x0000555555555686 <+45>:    cmp    %ebx,%eax 
   0x0000555555555688 <+47>:    jge    0x5555555556b9 <func4_2+96>
   0x000055555555568a <+49>:    lea    0x1(%rax),%edx # 判断 t+1 == k
   0x000055555555568d <+52>:    cmp    %ebx,%edx
   0x000055555555568f <+54>:    jne    0x5555555556d4 <func4_2+123>
   0x0000555555555691 <+56>:    mov    %r12b,0x0(%rbp)
   0x0000555555555695 <+60>:    mov    %r13b,0x1(%rbp)
   0x0000555555555699 <+64>:    movb   $0x0,0x2(%rbp)
   0x000055555555569d <+68>:    jmp    0x5555555556aa <func4_2+81>
   0x000055555555569f <+70>:    mov    %dl,0x0(%rbp) # base case跳到这 写字符串并结束 out[0]=c1; out[1]=c2;out[2]='\0';
   0x00005555555556a2 <+73>:    mov    %cl,0x1(%rbp)
   0x00005555555556a5 <+76>:    movb   $0x0,0x2(%r9)
```
```
   0x00005555555556aa <+81>:    add    $0x8,%rsp # ret前，返回出口，在这里设断点查看out
   0x00005555555556ae <+85>:    pop    %rbx
   0x00005555555556af <+86>:    pop    %rbp
   0x00005555555556b0 <+87>:    pop    %r12
   0x00005555555556b2 <+89>:    pop    %r13
   0x00005555555556b4 <+91>:    pop    %r14
   0x00005555555556b6 <+93>:    pop    %r15
   0x00005555555556b8 <+95>:    ret
```
```
   0x00005555555556b9 <+96>:    movsbl %r14b,%ecx # 参数重排
   0x00005555555556bd <+100>:   movsbl %r12b,%edx
   0x00005555555556c1 <+104>:   mov    %rbp,%r9
   0x00005555555556c4 <+107>:   movsbl %r13b,%r8d
   0x00005555555556c8 <+111>:   mov    %ebx,%esi
   0x00005555555556ca <+113>:   mov    %r15d,%edi
   0x00005555555556cd <+116>:   call   0x555555555659 <func4_2> # 递归调用func4_2(n-1,k,c1,c3,c2,out);字符顺序发生变化
   0x00005555555556d2 <+121>:   jmp    0x5555555556aa <func4_2+81>
   0x00005555555556d4 <+123>:   movsbl %r13b,%ecx #k修正
   0x00005555555556d8 <+127>:   movsbl %r14b,%edx
   0x00005555555556dc <+131>:   sub    %eax,%ebx
   0x00005555555556de <+133>:   lea    -0x1(%rbx),%esi
   0x00005555555556e1 <+136>:   mov    %rbp,%r9
   0x00005555555556e4 <+139>:   movsbl %r12b,%r8d
   0x00005555555556e8 <+143>:   mov    %r15d,%edi
   0x00005555555556eb <+146>:   call   0x555555555659 <func4_2># 递归func4_2(n-1,k - t - 1,c3,c2,c1,out);字符顺序再次变化
   0x00005555555556f0 <+151>:   jmp    0x5555555556aa <func4_2+81>
# 在一棵大小为2^n-1的递归结构中根据第k个位置走左/中/右，并在命中时输出两个字符
Breakpoint 8, 0x00005555555556aa in func4_2 ()
(gdb) x/s $rbp
0x7fffffffd984: "AB"
(gdb) x/3cb $rbp
0x7fffffffd984: 65 'A'  66 'B'  0 '\000'
得到第二个要求的值
```

### phase_5

```c
// 题目答案
-4 103
```
题目思路：
```
57cc: lea 0x1e04(%rip),%rsi
57d3: call __isoc99_sscanf
57d8: cmp $0x1,%eax
57db: jle explode
57dd: cmpl $0x0,(%rsp)
57e1: js explode
# 至少读到两个数
```

```
57e8: mov (%rsp),%eax
57eb: and $0xf,%eax
57ee: mov %eax,(%rsp)
57f1: cmp $0xf,%eax
57f4: je explode
# x = x & 0xf;
# if (x == 15) explode;
# 程序关心的是低4位
```

```
57f6: mov $0x0,%ecx   # sum = 0
57fb: mov $0x0,%edx   # count = 0
5800: lea array.0,%rsi
5807: add $0x1,%edx        # count++
580a: cltq                # eax -> rax
580c: mov (%rsi,%rax,4),%eax   # eax = array[x]
580f: add %eax,%ecx       # sum += eax
5811: cmp $0xf,%eax
5814: jne 5807            # 如果没到15就继续
do {
    count++;
    x = array[x];
    sum += x;
} while (x != 15);
```

```
5816: movl $0xf,(%rsp) # 终点是15
581d: cmp $0xe,%edx # 步数是14
5820: jne explode
5822: cmp %ecx,0x4(%rsp)
5826: je ok
5828: explode
# 第二个输入=路径上所有array[x]的和
```

```
(gdb) x/16dw 0x555555557240
0x555555557240 <array.0>:       10      2       14      7
0x555555557250 <array.0+16>:    8       12      15      11
0x555555557260 <array.0+32>:    0       4       1       13
0x555555557270 <array.0+48>:    3       9       6       5
```
```
0x0000555555555822 <+114>:   cmp    %ecx,0x4(%rsp) # 比较累加和与第二个输入
0x0000555555555826 <+118>:   je     0x55555555582d <phase_5+125> # 相等就通过
# 直接gdb查看累加和ecx，即第二个输入值:
Breakpoint 6, 0x0000555555555826 in phase_5 ()
(gdb) info registers ecx
ecx            0x67                103
找一条长14步且终点是15的路径,那么可以从15逆推，得到一条12 -> 3 -> 7 -> 11 -> 13 -> 9 -> 4 -> 8 -> 0 -> 10 -> 1 -> 2 -> 14 -> 6 -> 15的路，累加和正好是103，起始值是12，但要求是负数，12低四位1100，补码则是-4，所以第一个输入值是-4.
```

### phase_6

```c
// 题目答案
3 5 2 4 6 1
```

题目思路：
输入要求：6个1~6的互不相同数字
```
   ...
   0x0000555555555863 <+28>:    mov    %rsp,%r13 #%r13保存%rsp的值（输入数组起始地址）
   0x0000555555555866 <+31>:    mov    %r13,%rsi
   0x0000555555555869 <+34>:    call   0x555555555fab <read_six_numbers> # 调用read_six_numbers读取6个整数到栈上
   0x000055555555586e <+39>:    mov    $0x1,%r14d  #r14=1(外层循环计数器i)
   0x0000555555555874 <+45>:    mov    %rsp,%r12 # r12=输入数组起始地址
   0x0000555555555877 <+48>:    jmp    0x5555555558a1 <phase_6+90>
   0x0000555555555879 <+50>:    call   0x555555555eeb <explode_bomb>
   0x000055555555587e <+55>:    jmp    0x5555555558b0 <phase_6+105>
   0x0000555555555880 <+57>:    add    $0x1,%rbx
   0x0000555555555884 <+61>:    cmp    $0x5,%ebx
   0x0000555555555887 <+64>:    jg     0x555555555899 <phase_6+82> # 如果j>5，结束内层循环
   0x0000555555555889 <+66>:    mov    (%r12,%rbx,4),%eax # 内层循环eax = 输入数组[j]
   0x000055555555588d <+70>:    cmp    %eax,0x0(%rbp) # 比较数组[i]和数组[j]
   0x0000555555555890 <+73>:    jne    0x555555555880 <phase_6+57>
   0x0000555555555892 <+75>:    call   0x555555555eeb <explode_bomb>
   0x0000555555555897 <+80>:    jmp    0x555555555880 <phase_6+57>
   0x0000555555555899 <+82>:    add    $0x1,%r14
   0x000055555555589d <+86>:    add    $0x4,%r13
   0x00005555555558a1 <+90>:    mov    %r13,%rbp # 外层循环体 rbp 指向当前处理的数字地址
   0x00005555555558a4 <+93>:    mov    0x0(%r13),%eax # eax=当前数字
   0x00005555555558a8 <+97>:    sub    $0x1,%eax # eax-=1
   0x00005555555558ab <+100>:   cmp    $0x5,%eax
   0x00005555555558ae <+103>:   ja     0x555555555879 <phase_6+50># 如果eax>5或eax<0 (无符号比较) 检查每个数字是否在1~6之间
   #双重循环，确保6个数字互不相同,对于每个i，检查arr[i]是否与arr[j]相等（j > i）
```
链表操作：每个数字表示节点在原链表中的位置：
```
   0x00005555555558b0 <+105>:   cmp    $0x5,%r14d
   0x00005555555558b4 <+109>:   jg     0x5555555558bb <phase_6+116>
   0x00005555555558b6 <+111>:   mov    %r14,%rbx
   0x00005555555558b9 <+114>:   jmp    0x555555555889 <phase_6+66>
   0x00005555555558bb <+116>:   mov    $0x0,%esi      # esi = 0 (循环计数器k)
    0x00005555555558c0 <+121>:   mov    (%rsp,%rsi,4),%ecx  # ecx = 输入数字 arr[k]
    0x00005555555558c3 <+124>:   mov    $0x1,%eax      # eax = 1 (节点计数器)
    0x00005555555558c8 <+129>:   lea    0x4941(%rip),%rdx  # rdx = &node1
    0x00005555555558cf <+136>:   cmp    $0x1,%ecx       # 比较 arr[k] 和 1
    0x00005555555558d2 <+139>:   jle    0x5555555558df <phase_6+152>  # 如果 arr[k] ≤ 1
    # 循环：移动到第 arr[k] 个节点
    0x00005555555558d4 <+141>:   mov    0x8(%rdx),%rdx  # rdx = rdx->next
    0x00005555555558d8 <+145>:   add    $0x1,%eax      # eax++
    0x00005555555558db <+148>:   cmp    %ecx,%eax      # 比较 eax 和 arr[k]
    0x00005555555558dd <+150>:   jne    0x5555555558d4 <phase_6+141>  # 如果 eax ≠ arr[k]，继续
    0x00005555555558df <+152>:   mov    %rdx,0x20(%rsp,%rsi,8)  # 保存节点指针到栈数组
    0x00005555555558e4 <+157>:   add    $0x1,%rsi      # k++
    0x00005555555558e8 <+161>:   cmp    $0x6,%rsi      # 比较 k 和 6
    0x00005555555558ec <+165>:   jne    0x5555555558c0 <phase_6+121>  # 如果 k ≠ 6，继续循环0x00005555555558ee <+167>:   mov    0x20(%rsp),%rbx
    # 为每个输入数字 arr[k]找到对应的链表节点,从 node1开始，移动arr[k]-1次，得到指向对应节点的指针,将6个节点指针保存到栈数组 %rsp+0x20到 %rsp+0x50
```
```
    0x00005555555558ee <+167>:   mov    0x20(%rsp),%rbx  # rbx = 第一个节点指针
    0x00005555555558f3 <+172>:   mov    0x28(%rsp),%rax  # rax = 第二个节点指针
    0x00005555555558f8 <+177>:   mov    %rax,0x8(%rbx)   # node1->next = node2
    0x00005555555558fc <+181>:   mov    0x30(%rsp),%rdx  # rdx = 第三个节点指针
    0x0000555555555901 <+186>:   mov    %rdx,0x8(%rax)   # node2->next = node3
    0x0000555555555905 <+190>:   mov    0x38(%rsp),%rax  # rax = 第四个节点指针
    0x000055555555590a <+195>:   mov    %rax,0x8(%rdx)   # node3->next = node4
    0x000055555555590e <+199>:   mov    0x40(%rsp),%rdx  # rdx = 第五个节点指针
    0x0000555555555913 <+204>:   mov    %rdx,0x8(%rax)   # node4->next = node5
    0x0000555555555917 <208>:    mov    0x48(%rsp),%rax  # rax = 第六个节点指针
    0x000055555555591c <213>:    mov    %rax,0x8(%rdx)   # node5->next = node6
    0x0000555555555920 <217>:    movq   $0x0,0x8(%rax)   # node6->next = NULL
```
根据输入数字的顺序，重新连接链表，新链表的节点值必须按非递减顺序排列：
```
   0x0000555555555928 <+225>:   mov    $0x5,%ebp # ebp = 5 (循环计数器，需要检查5对节点)
   0x000055555555592d <+230>:   jmp    0x555555555938 <phase_6+241>
   0x000055555555592f <+232>:   mov    0x8(%rbx),%rbx # rbx = rbx->next (移动到下一个节点)
   0x0000555555555933 <+236>:   sub    $0x1,%ebp
   0x0000555555555936 <+239>:   je     0x555555555949 <phase_6+258> # 如果 ebp == 0，结束
   0x0000555555555938 <+241>:   mov    0x8(%rbx),%rax # rax = node->next # 继续循环
   0x000055555555593c <+245>:   mov    (%rax),%eax # eax = node->next->value
   0x000055555555593e <+247>:   cmp    %eax,(%rbx)  # 比较 node->value 和 node->next->value
   0x0000555555555940 <+249>:   jle    0x55555555592f <phase_6+232> # 如果 node->value ≤ next->value
   # 遍历新链表，检查每个节点的值是否≤下一个节点的值,不满足非递减顺序（即升序），则引爆炸弹
   0x0000555555555942 <+251>:   call   0x555555555eeb <explode_bomb>
   ...
End of assembler dump.
```
```
链表结构大概是： value(4字节), index(4字节), next(8字节)
struct node {
    int value;
    int index;
    struct node *next;
};
```
查看每个节点的值：
```
(gdb)  x/24w 0x55555555a210
0x55555555a210 <node1>: 0x000003cc      0x00000001      0x00006220      0x00000000
0x55555555a220 <node2>: 0x000001ec      0x00000002      0x00006230      0x00000000
0x55555555a230 <node3>: 0x00000160      0x00000003      0x00006240      0x00000000
0x55555555a240 <node4>: 0x000002d6      0x00000004      0x00006250      0x00000000
0x55555555a250 <node5>: 0x00000177      0x00000005      0x00006160      0x00000000
0x55555555a260 <host_table>:    0x00003628      0x00000000      0x0000362d      0x00000000
#通过node5第三列(next):0x00006160得到node6地址0x55555555a160
(gdb) x/4xw 0x55555555a160
0x55555555a160 <node6>: 0x0000034a      0x00000006      0x00000000      0x00000000
```
```
(gdb)  x/24wd 0x55555555a210
0x55555555a210 <node1>: 972     1       1431675424      21845
0x55555555a220 <node2>: 492     2       1431675440      21845
0x55555555a230 <node3>: 352     3       1431675456      21845
0x55555555a240 <node4>: 726     4       1431675472      21845
0x55555555a250 <node5>: 375     5       1431675232      21845
0x55555555a260 <host_table>:    1431664168      21845   1431664173      21845
(gdb) x/4xwd 0x55555555a160
0x55555555a160 <node6>: 842     6       0       0
```
升序排列即得输入数字顺序3 5 2 4 6 1
<!-- 这一节，你可以简单描述你在这个 lab 上花费的时间/你认为的难度/你认为不合理的地方/你认为有趣的地方 -->

<!-- 或者是收获/感悟/总结 -->

<!-- 200 字以内，可以不写 -->

## 参考的重要资料

<!-- 有哪些文章/论文/PPT/课本对你的实现有重要启发或者帮助，或者是你直接引用了某个方法 -->

<!-- 请附上文章标题和可访问的网页路径 -->
[Introduction-to-Computer-System-2023Fall-PKU](https://github.com/zhuozhiyongde/Introduction-to-Computer-System-2023Fall-PKU/tree/main/02-Bomb-Lab)

